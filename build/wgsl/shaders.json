{"quad":{"vertex":"struct VSOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) fragUV: vec2<f32>\r\n};\r\n\r\n@vertex\r\nfn main(@location(0) inPos: vec2<f32>) -> VSOut {\r\n    var vsOut: VSOut;\r\n    vsOut.position = vec4<f32>(inPos, 0.0, 1.0);\r\n    vsOut.fragUV = (inPos + vec2<f32>(1.0, -1.0)) * vec2<f32>(0.5, -0.5);\r\n    return vsOut;\r\n}\n","fragment":"@group(0) @binding(0) var uSampler: sampler;\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(@location(0) fragUV: vec2<f32>) -> @location(0) vec4<f32> {\r\n    return textureSample(uTexture, uSampler, fragUV);\r\n    //return vec4<f32>(fragUV.x, fragUV.y, 0.0, 1.0);\r\n}\n"},"renderers":{"EAM":{"generate":{"vertex":"struct VSOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) rayFrom: vec3<f32>,\r\n    @location(1) rayTo: vec3<f32>\r\n};\r\n\r\nstruct UBO {\r\n    mvpInvMat: mat4x4<f32>,\r\n    stepSize: f32,\r\n    offset: f32,\r\n    extinction: f32\r\n};\r\n@group(0) @binding(0) var<uniform> ubo: UBO;\r\n\r\n\r\n@vertex\r\nfn main(@location(0) inPos: vec2<f32>) -> VSOut {\r\n    var vsOut: VSOut;\r\n    vsOut.position = vec4<f32>(inPos, 0.0, 1.0);\r\n\r\n    // TODO: Include unproject\r\n    var nearPosition = vec4<f32>(inPos, -1.0, 1.0);\r\n    var farPosition = vec4<f32>(inPos, 1.0, 1.0);\r\n    var fromDirty: vec4<f32> = ubo.mvpInvMat * nearPosition;\r\n    var toDirty: vec4<f32> = ubo.mvpInvMat * farPosition;\r\n    vsOut.rayFrom = vec3<f32>(fromDirty.x, fromDirty.y, fromDirty.z) / fromDirty.w;\r\n    vsOut.rayTo = vec3<f32>(toDirty.x, toDirty.y, toDirty.z) / toDirty.w;\r\n\r\n    return vsOut;\r\n}\n","fragment":"struct UBO {\r\n    mvpInvMat: mat4x4<f32>,\r\n    stepSize: f32,\r\n    offset: f32,\r\n    extinction: f32\r\n};\r\n@group(0) @binding(0) var<uniform> ubo: UBO;\r\n@group(0) @binding(1) var uSampler: sampler;\r\n@group(0) @binding(2) var uVolume: texture_3d<f32>;\r\n@group(0) @binding(3) var uTransferFunction: texture_2d<f32>;\r\n\r\n// TODO: Link intersectCube\r\nfn intersectCube(origin: vec3<f32>, direction: vec3<f32>) -> vec2<f32> {\r\n\tvar tmin: vec3<f32> = (vec3<f32>(0.0) - origin) / direction;\r\n\tvar tmax: vec3<f32> = (vec3<f32>(1.0) - origin) / direction;\r\n\r\n\tvar t1: vec3<f32> = min(tmin, tmax);\r\n\tvar t2: vec3<f32> = max(tmin, tmax);\r\n\r\n\tvar tnear: f32 = max(max(t1.x, t1.y), t1.z);\r\n\tvar tfar: f32 = min(min(t2.x, t2.y), t2.z);\r\n\r\n\treturn vec2<f32>(tnear, tfar);\r\n}\r\n\r\nfn sampleVolumeColor(position: vec3<f32>) -> vec4<f32> {\r\n    // TODO\r\n    //return vec4<f32>(0.2, 0.4, 0.6, 1.0);\r\n\r\n    // var sample: f32 = textureSample(uVolume, uSampler, position).r;\r\n    // return vec4<f32>(sample, sample, sample, 1.0);\r\n\r\n    var volumeSample: vec2<f32> = textureSample(uVolume, uSampler, position).rg;\r\n    var transferSample: vec4<f32> = textureSample(uTransferFunction, uSampler, volumeSample);\r\n    return transferSample;\r\n\r\n    // vec2 volumeSample = texture(uVolume, position).rg;\r\n    // vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    // return transferSample;\r\n}\r\n\r\n@fragment\r\nfn main(@location(0) rayFrom: vec3<f32>, @location(1) rayTo: vec3<f32>) -> @location(0) vec4<f32> {\r\n    var rayDirection: vec3<f32> = rayTo - rayFrom;\r\n    var tbounds: vec2<f32> = max(intersectCube(rayFrom, rayDirection), vec2<f32>(0.0));\r\n\r\n    if (tbounds.x >= tbounds.y) {\r\n        return vec4<f32>(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n    \r\n    var from: vec3<f32> = mix(rayFrom, rayTo, tbounds.x);\r\n    var to: vec3<f32> = mix(rayFrom, rayTo, tbounds.y);\r\n\r\n    var rayStepLength: f32 = distance(from, to) * ubo.stepSize;\r\n\r\n    var t: f32 = 0.0;\r\n    var accumulator = vec4<f32>(0.0);\r\n\r\n    for (;t < 1.0 && accumulator.a < 0.99;) { // TODO: Use while loop\r\n        var position: vec3<f32> = mix(from, to, t);\r\n        var colorSample = sampleVolumeColor(position);\r\n        colorSample.a *= rayStepLength * ubo.extinction;\r\n        colorSample = vec4<f32>(colorSample.rgb * colorSample.a, colorSample.a);\r\n        accumulator += (1.0 - accumulator.a) * colorSample;\r\n        t += ubo.stepSize;\r\n    }\r\n\r\n    if (accumulator.a > 1.0) {\r\n        accumulator = vec4<f32>(accumulator.rgb / accumulator.a, accumulator.a);\r\n    }\r\n\r\n    return vec4<f32>(accumulator.rgb, 1.0);\r\n}\n"},"integrate":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = texture(uFrame, vPosition);\r\n}\n"},"render":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = texture(uAccumulator, vPosition);\r\n}\n"},"reset":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = vec4(0, 0, 0, 1);\r\n}\n"}},"ISO":{"generate":{"vertex":"struct VSOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) rayFrom: vec3<f32>,\r\n    @location(1) rayTo: vec3<f32>,\r\n    @location(2) pos: vec2<f32>\r\n};\r\n\r\nstruct UBO {\r\n    mvpInvMat: mat4x4<f32>,\r\n    stepSize: f32,\r\n    offset: f32,\r\n    isovalue: f32\r\n};\r\n@group(0) @binding(0) var<uniform> ubo: UBO;\r\n\r\n\r\n@stage(vertex)\r\nfn main(@location(0) inPos: vec2<f32>) -> VSOut {\r\n    var vsOut: VSOut;\r\n    vsOut.position = vec4<f32>(inPos, 0.0, 1.0);\r\n    vsOut.pos = inPos * 0.5 + 0.5;\r\n\r\n    // TODO: Include unproject\r\n    var nearPosition = vec4<f32>(inPos, -1.0, 1.0);\r\n    var farPosition = vec4<f32>(inPos, 1.0, 1.0);\r\n    var fromDirty: vec4<f32> = ubo.mvpInvMat * nearPosition;\r\n    var toDirty: vec4<f32> = ubo.mvpInvMat * farPosition;\r\n    vsOut.rayFrom = vec3<f32>(fromDirty.x, fromDirty.y, fromDirty.z) / fromDirty.w;\r\n    vsOut.rayTo = vec3<f32>(toDirty.x, toDirty.y, toDirty.z) / toDirty.w;\r\n\r\n    return vsOut;\r\n}\n","fragment":"struct UBO {\r\n    mvpInvMat: mat4x4<f32>,\r\n    stepSize: f32,\r\n    offset: f32,\r\n    isovalue: f32\r\n};\r\n@group(0) @binding(0) var<uniform> ubo: UBO;\r\n@group(0) @binding(1) var uSampler: sampler;\r\n@group(0) @binding(2) var uTexture: texture_3d<f32>;\r\n\r\n// TODO: Link intersectCube\r\nfn intersectCube(origin: vec3<f32>, direction: vec3<f32>) -> vec2<f32> {\r\n\tvar tmin: vec3<f32> = (vec3<f32>(0.0) - origin) / direction;\r\n\tvar tmax: vec3<f32> = (vec3<f32>(1.0) - origin) / direction;\r\n\r\n\tvar t1: vec3<f32> = min(tmin, tmax);\r\n\tvar t2: vec3<f32> = max(tmin, tmax);\r\n\r\n\tvar tnear: f32 = max(max(t1.x, t1.y), t1.z);\r\n\tvar tfar: f32 = min(min(t2.x, t2.y), t2.z);\r\n\r\n\treturn vec2<f32>(tnear, tfar);\r\n}\r\n\r\n@stage(fragment)\r\nfn main(@location(0) rayFrom: vec3<f32>, @location(1) rayTo: vec3<f32>, @location(2) vPosition: vec2<f32>) -> @location(0) vec4<f32> {\r\n    var rayDirection: vec3<f32> = rayTo - rayFrom;\r\n    var tbounds: vec2<f32> = max(intersectCube(rayFrom, rayDirection), vec2<f32>(0.0));\r\n\r\n    if (tbounds.x >= tbounds.y) {\r\n        return vec4<f32>(-1.0);\r\n    }\r\n\r\n    var from: vec4<f32> = vec4<f32>(mix(rayFrom, rayTo, tbounds.x), tbounds.x);\r\n    var to: vec4<f32> = vec4<f32>(mix(rayFrom, rayTo, tbounds.y), tbounds.y);\r\n\r\n    var closest: f32 = -1.0; // textureSample(uClosest, uSampler, vPosition).w\r\n    if (closest > 0.0) {\r\n        tbounds.y = closest;\r\n    }\r\n\r\n    var t: f32 = 0.0;\r\n    var offset: f32 = ubo.offset;\r\n    var pos: vec3<f32>;\r\n    var value: f32;\r\n    var found: bool = false;\r\n\r\n    for (;t < 1.0;) { // TODO: Use while loop\r\n        pos = mix(from.xyz, to.xyz, offset);\r\n        value = textureSample(uTexture, uSampler, pos).r;\r\n        if (value >= ubo.isovalue) {\r\n            tbounds.y = mix(from.w, to.w, offset);\r\n            to = vec4<f32>(mix(rayFrom, rayTo, tbounds.y), tbounds.y);\r\n            found = true;\r\n        }\r\n        t += ubo.stepSize;\r\n        offset = fract(offset + ubo.stepSize + ubo.offset);\r\n    }\r\n\r\n    if (found) {\r\n        //return to;\r\n        return vec4<f32>(0.0, 0.0, 0.0, 1.0);\r\n    } else {\r\n        return vec4<f32>(-1.0);\r\n    }\r\n}\n"},"integrate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\n\r\nin vec2 vPosition;\r\n\r\nout vec4 oClosest;\r\n\r\nvoid main() {\r\n    vec4 frame = texture(uFrame, vPosition);\r\n    vec4 acc = texture(uAccumulator, vPosition);\r\n    if (frame.w > 0.0 && acc.w > 0.0) {\r\n        oClosest = frame.w < acc.w ? frame : acc;\r\n    } else if (frame.w > 0.0) {\r\n        oClosest = frame;\r\n    } else {\r\n        oClosest = acc;\r\n    }\r\n}\n"},"render":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uClosest;\r\nuniform mediump sampler3D uVolume;\r\nuniform vec3 uLight;\r\nuniform vec3 uDiffuse;\r\n\r\nin vec2 vPosition;\r\n\r\nout vec4 oColor;\r\n\r\nvec3 gradient(vec3 pos, float h) {\r\n    vec3 positive = vec3(\r\n        texture(uVolume, pos + vec3( h, 0.0, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0,  h, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, 0.0,  h)).r\r\n    );\r\n    vec3 negative = vec3(\r\n        texture(uVolume, pos + vec3(-h, 0.0, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, -h, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, 0.0, -h)).r\r\n    );\r\n    return normalize(positive - negative);\r\n}\r\n\r\nvoid main() {\r\n    vec4 closest = texture(uClosest, vPosition);\r\n\r\n    if (closest.w > 0.0) {\r\n        vec3 normal = normalize(gradient(closest.xyz, 0.005));\r\n        vec3 light = normalize(uLight);\r\n        float lambert = max(dot(normal, light), 0.0);\r\n        oColor = vec4(uDiffuse * lambert, 1.0);\r\n    } else {\r\n        oColor = vec4(1.0);\r\n    }\r\n}\n"},"reset":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 oClosest;\r\n\r\nvoid main() {\r\n    oClosest = vec4(-1);\r\n}\n"}}}}