{"average":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vFragmentPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTextureAccumulator;\r\nuniform mediump sampler2D uTextureNew;\r\nuniform float uInvn; // inverse number of samples\r\n\r\nin vec2 vFragmentPosition;\r\nout vec4 color;\r\n\r\nvoid main() {\r\n    vec4 a = texture(uTextureAccumulator, vFragmentPosition);\r\n    vec4 b = texture(uTextureNew, vFragmentPosition);\r\n    color = a + (b - a) * uInvn;\r\n}\n"},"drawTransferFunction":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform vec2 uPosition;\r\nuniform vec2 uSize;\r\nuniform vec4 uColor;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    float r = length((uPosition - vPosition) / uSize);\r\n    oColor = uColor * exp(-r * r);\r\n}\n"},"quad":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vFragmentPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\n\r\nin vec2 vFragmentPosition;\r\nout vec4 color;\r\n\r\nvoid main() {\r\n    color = texture(uTexture, vFragmentPosition);\r\n}\n"},"renderers":{"DOS":{"integrate":{"vertex":"#version 300 es\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform float uDepth;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition2D;\r\nout vec3 vPosition3D;\r\n\r\nvoid main() {\r\n    vec4 dirty = uMvpInverseMatrix * vec4(aPosition, uDepth, 1);\r\n    vPosition3D = dirty.xyz / dirty.w;\r\n    vPosition2D = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\n\r\nuniform mediump sampler2D uColor;\r\nuniform mediump sampler2D uOcclusion;\r\nuniform mediump sampler2D uOcclusionSamples;\r\n\r\nuniform float uExtinction;\r\nuniform float uSliceDistance;\r\nuniform vec2 uOcclusionScale;\r\nuniform uint uOcclusionSamplesCount;\r\n\r\nin vec2 vPosition2D;\r\nin vec3 vPosition3D;\r\n\r\nlayout (location = 0) out vec4 oColor;\r\nlayout (location = 1) out float oOcclusion;\r\n\r\nvec4 sampleVolumeColor(vec3 position) {\r\n    vec2 volumeSample = texture(uVolume, position).rg;\r\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    return transferSample;\r\n}\r\n\r\nfloat calculateOcclusion(float extinction) {\r\n    float occlusion = 0.0;\r\n    for (uint i = 0u; i < uOcclusionSamplesCount; i++) {\r\n        vec2 occlusionSampleOffset = texelFetch(uOcclusionSamples, ivec2(i, 0), 0).rg;\r\n        vec2 occlusionSamplePosition = vPosition2D + occlusionSampleOffset * uOcclusionScale;\r\n        occlusion += texture(uOcclusion, occlusionSamplePosition).r;\r\n    }\r\n    return (occlusion / float(uOcclusionSamplesCount)) * exp(-extinction * uSliceDistance);\r\n}\r\n\r\nvoid main() {\r\n    vec4 prevColor = texture(uColor, vPosition2D);\r\n    float prevOcclusion = texture(uOcclusion, vPosition2D).r;\r\n\r\n    if (any(greaterThan(vPosition3D, vec3(1))) || any(lessThan(vPosition3D, vec3(0)))) {\r\n        oColor = prevColor;\r\n        oOcclusion = prevOcclusion;\r\n    } else {\r\n        vec4 transferSample = sampleVolumeColor(vPosition3D);\r\n        float extinction = transferSample.a * uExtinction;\r\n        float alpha = 1.0 - exp(-extinction * uSliceDistance);\r\n        vec3 color = transferSample.rgb * prevOcclusion * alpha;\r\n        oColor = prevColor + vec4(color * (1.0 - prevColor.a), alpha);\r\n        oColor.a = min(oColor.a, 1.0);\r\n        oOcclusion = calculateOcclusion(extinction);\r\n    }\r\n}\n"},"render":{"vertex":"#version 300 es\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    vec4 color = texture(uAccumulator, vPosition);\r\n    oColor = mix(vec4(1), vec4(color.rgb, 1), color.a);\r\n}\n"},"reset":{"vertex":"#version 300 es\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) out vec4 oColor;\r\nlayout (location = 1) out float oOcclusion;\r\n\r\nvoid main() {\r\n    oColor = vec4(0);\r\n    oOcclusion = 1.0;\r\n}\n"}},"EAM":{"generate":{"vertex":"#version 300 es\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec3 vRayFrom;\r\nout vec3 vRayTo;\r\n\r\n// #link /glsl/mixins/unproject.glsl\r\n@unproject\r\n\r\nvoid main() {\r\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\nuniform float uStepSize;\r\nuniform float uOffset;\r\nuniform float uExtinction;\r\n\r\nin vec3 vRayFrom;\r\nin vec3 vRayTo;\r\nout vec4 oColor;\r\n\r\n// #link /glsl/mixins/intersectCube.glsl\r\n@intersectCube\r\n\r\nvec4 sampleVolumeColor(vec3 position) {\r\n    vec2 volumeSample = texture(uVolume, position).rg;\r\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    return transferSample;\r\n}\r\n\r\nvoid main() {\r\n    vec3 rayDirection = vRayTo - vRayFrom;\r\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\r\n    if (tbounds.x >= tbounds.y) {\r\n        oColor = vec4(0, 0, 0, 1);\r\n    } else {\r\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\r\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\r\n        float rayStepLength = distance(from, to) * uStepSize;\r\n\r\n        float t = 0.0;\r\n        vec4 accumulator = vec4(0);\r\n\r\n        while (t < 1.0 && accumulator.a < 0.99) {\r\n            vec3 position = mix(from, to, t);\r\n            vec4 colorSample = sampleVolumeColor(position);\r\n            colorSample.a *= rayStepLength * uExtinction;\r\n            colorSample.rgb *= colorSample.a;\r\n            accumulator += (1.0 - accumulator.a) * colorSample;\r\n            t += uStepSize;\r\n        }\r\n\r\n        if (accumulator.a > 1.0) {\r\n            accumulator.rgb /= accumulator.a;\r\n        }\r\n\r\n        oColor = vec4(accumulator.rgb, 1);\r\n    }\r\n}\n"},"integrate":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = texture(uFrame, vPosition);\r\n}\n"},"render":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = texture(uAccumulator, vPosition);\r\n}\n"},"reset":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = vec4(0, 0, 0, 1);\r\n}\n"}},"ISO":{"generate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\nout vec3 vRayFrom;\r\nout vec3 vRayTo;\r\n\r\n// #link /glsl/mixins/unproject\r\n@unproject\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uClosest;\r\nuniform mediump sampler3D uVolume;\r\nuniform float uStepSize;\r\nuniform float uOffset;\r\nuniform float uIsovalue;\r\n\r\nin vec2 vPosition;\r\nin vec3 vRayFrom;\r\nin vec3 vRayTo;\r\n\r\nout vec4 oClosest;\r\n\r\n// #link /glsl/mixins/intersectCube\r\n@intersectCube\r\n\r\nvoid main() {\r\n    vec3 rayDirection = vRayTo - vRayFrom;\r\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\r\n    if (tbounds.x >= tbounds.y) {\r\n        oClosest = vec4(-1);\r\n    } else {\r\n        vec4 from = vec4(mix(vRayFrom, vRayTo, tbounds.x), tbounds.x);\r\n        vec4 to = vec4(mix(vRayFrom, vRayTo, tbounds.y), tbounds.y);\r\n\r\n        float closest = texture(uClosest, vPosition).w;\r\n        if (closest > 0.0) {\r\n            tbounds.y = closest;\r\n        }\r\n\r\n        float t = 0.0;\r\n        float offset = uOffset;\r\n        vec3 pos;\r\n        float value;\r\n        bool found = false;\r\n        do {\r\n            pos = mix(from.xyz, to.xyz, offset);\r\n            value = texture(uVolume, pos).r;\r\n            if (value >= uIsovalue) {\r\n                tbounds.y = mix(from.w, to.w, offset);\r\n                to = vec4(mix(vRayFrom, vRayTo, tbounds.y), tbounds.y);\r\n                found = true;\r\n            }\r\n            t += uStepSize;\r\n            offset = mod(offset + uStepSize + uOffset, 1.0);\r\n        } while (t < 1.0);\r\n\r\n        if (found) {\r\n            oClosest = to;\r\n        } else {\r\n            oClosest = vec4(-1);\r\n        }\r\n    }\r\n}\n"},"integrate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\n\r\nin vec2 vPosition;\r\n\r\nout vec4 oClosest;\r\n\r\nvoid main() {\r\n    vec4 frame = texture(uFrame, vPosition);\r\n    vec4 acc = texture(uAccumulator, vPosition);\r\n    if (frame.w > 0.0 && acc.w > 0.0) {\r\n        oClosest = frame.w < acc.w ? frame : acc;\r\n    } else if (frame.w > 0.0) {\r\n        oClosest = frame;\r\n    } else {\r\n        oClosest = acc;\r\n    }\r\n}\n"},"render":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uClosest;\r\nuniform mediump sampler3D uVolume;\r\nuniform vec3 uLight;\r\nuniform vec3 uDiffuse;\r\n\r\nin vec2 vPosition;\r\n\r\nout vec4 oColor;\r\n\r\nvec3 gradient(vec3 pos, float h) {\r\n    vec3 positive = vec3(\r\n        texture(uVolume, pos + vec3( h, 0.0, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0,  h, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, 0.0,  h)).r\r\n    );\r\n    vec3 negative = vec3(\r\n        texture(uVolume, pos + vec3(-h, 0.0, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, -h, 0.0)).r,\r\n        texture(uVolume, pos + vec3(0.0, 0.0, -h)).r\r\n    );\r\n    return normalize(positive - negative);\r\n}\r\n\r\nvoid main() {\r\n    vec4 closest = texture(uClosest, vPosition);\r\n\r\n    if (closest.w > 0.0) {\r\n        vec3 normal = normalize(gradient(closest.xyz, 0.005));\r\n        vec3 light = normalize(uLight);\r\n        float lambert = max(dot(normal, light), 0.0);\r\n        oColor = vec4(uDiffuse * lambert, 1.0);\r\n    } else {\r\n        oColor = vec4(1.0);\r\n    }\r\n}\n"},"reset":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 oClosest;\r\n\r\nvoid main() {\r\n    oClosest = vec4(-1);\r\n}\n"}},"MCC":{"render":{"compute":"#version 310 es\r\nlayout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\r\n\r\n#define M_INVPI 0.31830988618\r\n#define M_2PI 6.28318530718\r\n#define EPS 1e-5\r\n\r\n// #link /glsl/mixins/Photon\r\n@Photon\r\n// #link /glsl/mixins/rand\r\n@rand\r\n// #link /glsl/mixins/unprojectRand\r\n@unprojectRand\r\n// #link /glsl/mixins/intersectCube\r\n@intersectCube\r\n\r\nlayout (std430, binding = 0) buffer bPhotons {\r\n    Photon sPhotons[];\r\n};\r\n\r\nlayout (rgba32f, binding = 0) restrict writeonly highp uniform image2D oRadiance;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\nuniform mediump sampler2D uEnvironment;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform vec2 uInverseResolution;\r\nuniform float uRandSeed;\r\nuniform float uBlur;\r\n\r\nuniform float uAbsorptionCoefficient;\r\nuniform float uScatteringCoefficient;\r\nuniform float uScatteringBias;\r\nuniform float uMajorant;\r\nuniform uint uMaxBounces;\r\nuniform uint uSteps;\r\n\r\nvoid resetPhoton(inout vec2 randState, inout Photon photon) {\r\n    vec3 from, to;\r\n    vec2 screen = vec2(gl_GlobalInvocationID.xy) * uInverseResolution * 2.0 - 1.0;\r\n    unprojectRand(randState, screen, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\r\n    photon.direction = normalize(to - from);\r\n    photon.bounces = 0u;\r\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\r\n    photon.position = from + tbounds.x * photon.direction;\r\n    photon.transmittance = vec3(1);\r\n}\r\n\r\nvec4 sampleEnvironmentMap(vec3 d) {\r\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\r\n    return texture(uEnvironment, texCoord);\r\n}\r\n\r\nvec4 sampleVolumeColor(vec3 position) {\r\n    vec2 volumeSample = texture(uVolume, position).rg;\r\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    return transferSample;\r\n}\r\n\r\nvec3 randomDirection(vec2 U) {\r\n    float phi = U.x * M_2PI;\r\n    float z = U.y * 2.0 - 1.0;\r\n    float k = sqrt(1.0 - z * z);\r\n    return vec3(k * cos(phi), k * sin(phi), z);\r\n}\r\n\r\nfloat sampleHenyeyGreensteinAngleCosine(float g, float U) {\r\n    float g2 = g * g;\r\n    float c = (1.0 - g2) / (1.0 - g + 2.0 * g * U);\r\n    return (1.0 + g2 - c * c) / (2.0 * g);\r\n}\r\n\r\nvec3 sampleHenyeyGreenstein(float g, vec2 U, vec3 direction) {\r\n    // generate random direction and adjust it so that the angle is HG-sampled\r\n    vec3 u = randomDirection(U);\r\n    if (abs(g) < EPS) {\r\n        return u;\r\n    }\r\n    float hgcos = sampleHenyeyGreensteinAngleCosine(g, fract(sin(U.x * 12345.6789) + 0.816723));\r\n    float lambda = hgcos - dot(direction, u);\r\n    return normalize(u + lambda * direction);\r\n}\r\n\r\nvoid main() {\r\n    uvec3 globalSize = gl_WorkGroupSize * gl_NumWorkGroups;\r\n    uint globalInvocationIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * globalSize.x;\r\n    Photon photon = sPhotons[globalInvocationIndex];\r\n\r\n    vec2 r = rand(vec2(gl_GlobalInvocationID.xy) * uRandSeed);\r\n    for (uint i = 0u; i < uSteps; i++) {\r\n        r = rand(r);\r\n        float t = -log(r.x) / uMajorant;\r\n        photon.position += t * photon.direction;\r\n\r\n        vec4 volumeSample = sampleVolumeColor(photon.position);\r\n        float muAbsorption = volumeSample.a * uAbsorptionCoefficient;\r\n        float muScattering = volumeSample.a * uScatteringCoefficient;\r\n        float muNull = uMajorant - muAbsorption - muScattering;\r\n        float muMajorant = muAbsorption + muScattering + abs(muNull);\r\n        float PNull = abs(muNull) / muMajorant;\r\n        float PAbsorption = muAbsorption / muMajorant;\r\n        float PScattering = muScattering / muMajorant;\r\n\r\n        if (any(greaterThan(photon.position, vec3(1))) || any(lessThan(photon.position, vec3(0)))) {\r\n            // out of bounds\r\n            vec4 envSample = sampleEnvironmentMap(photon.direction);\r\n            vec3 radiance = photon.transmittance * envSample.rgb;\r\n            photon.samples++;\r\n            photon.radiance += (radiance - photon.radiance) / float(photon.samples);\r\n            imageStore(oRadiance, ivec2(gl_GlobalInvocationID.xy), vec4(photon.radiance, 1));\r\n            resetPhoton(r, photon);\r\n        } else if (photon.bounces >= uMaxBounces) {\r\n            // max bounces achieved -> only estimate transmittance\r\n            float weightAS = (muAbsorption + muScattering) / uMajorant;\r\n            photon.transmittance *= 1.0 - weightAS;\r\n        } else if (r.y < PAbsorption) {\r\n            // absorption\r\n            float weightA = muAbsorption / (uMajorant * PAbsorption);\r\n            photon.transmittance *= 1.0 - weightA;\r\n        } else if (r.y < PAbsorption + PScattering) {\r\n            // scattering\r\n            r = rand(r);\r\n            float weightS = muScattering / (uMajorant * PScattering);\r\n            photon.transmittance *= volumeSample.rgb * weightS;\r\n            photon.direction = sampleHenyeyGreenstein(uScatteringBias, r, photon.direction);\r\n            photon.bounces++;\r\n        } else {\r\n            // null collision\r\n            float weightN = muNull / (uMajorant * PNull);\r\n            photon.transmittance *= weightN;\r\n        }\r\n    }\r\n\r\n    sPhotons[globalInvocationIndex] = photon;\r\n}\n"},"reset":{"compute":"#version 310 es\r\nlayout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform vec2 uInverseResolution;\r\nuniform float uRandSeed;\r\nuniform float uBlur;\r\n\r\n// #link /glsl/mixins/Photon\r\n@Photon\r\n// #link /glsl/mixins/rand\r\n@rand\r\n// #link /glsl/mixins/unprojectRand\r\n@unprojectRand\r\n// #link /glsl/mixins/intersectCube\r\n@intersectCube\r\n\r\nlayout (std430, binding = 0) buffer bPhotons {\r\n    Photon sPhotons[];\r\n};\r\n\r\nvoid main() {\r\n    Photon photon;\r\n    vec3 from, to;\r\n    vec2 screen = vec2(gl_GlobalInvocationID.xy) * uInverseResolution * 2.0 - 1.0;\r\n    vec2 randState = rand(screen * uRandSeed);\r\n    unprojectRand(randState, screen, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\r\n    photon.direction = normalize(to - from);\r\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\r\n    photon.position = from + tbounds.x * photon.direction;\r\n    photon.transmittance = vec3(1);\r\n    photon.radiance = vec3(1);\r\n    photon.bounces = 0u;\r\n    photon.samples = 0u;\r\n    uvec3 globalSize = gl_WorkGroupSize * gl_NumWorkGroups;\r\n    uint globalInvocationIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * globalSize.x;\r\n    sPhotons[globalInvocationIndex] = photon;\r\n}\n"}},"MCM":{"integrate":{"vertex":"#version 300 es\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\n#define M_INVPI 0.31830988618\r\n#define M_2PI 6.28318530718\r\n#define EPS 1e-5\r\n\r\n// #link /glsl/mixins/Photon\r\n@Photon\r\n// #link /glsl/mixins/rand\r\n@rand\r\n// #link /glsl/mixins/unprojectRand\r\n@unprojectRand\r\n// #link /glsl/mixins/intersectCube\r\n@intersectCube\r\n\r\nuniform mediump sampler2D uPosition;\r\nuniform mediump sampler2D uDirection;\r\nuniform mediump sampler2D uTransmittance;\r\nuniform mediump sampler2D uRadiance;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\nuniform mediump sampler2D uEnvironment;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform vec2 uInverseResolution;\r\nuniform float uRandSeed;\r\nuniform float uBlur;\r\n\r\nuniform float uAbsorptionCoefficient;\r\nuniform float uScatteringCoefficient;\r\nuniform float uScatteringBias;\r\nuniform float uMajorant;\r\nuniform uint uMaxBounces;\r\nuniform uint uSteps;\r\n\r\nin vec2 vPosition;\r\n\r\nlayout (location = 0) out vec4 oPosition;\r\nlayout (location = 1) out vec4 oDirection;\r\nlayout (location = 2) out vec4 oTransmittance;\r\nlayout (location = 3) out vec4 oRadiance;\r\n\r\nvoid resetPhoton(inout vec2 randState, inout Photon photon) {\r\n    vec3 from, to;\r\n    unprojectRand(randState, vPosition, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\r\n    photon.direction = normalize(to - from);\r\n    photon.bounces = 0u;\r\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\r\n    photon.position = from + tbounds.x * photon.direction;\r\n    photon.transmittance = vec3(1);\r\n}\r\n\r\nvec4 sampleEnvironmentMap(vec3 d) {\r\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\r\n    return texture(uEnvironment, texCoord);\r\n}\r\n\r\nvec4 sampleVolumeColor(vec3 position) {\r\n    vec2 volumeSample = texture(uVolume, position).rg;\r\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    return transferSample;\r\n}\r\n\r\nvec3 randomDirection(vec2 U) {\r\n    float phi = U.x * M_2PI;\r\n    float z = U.y * 2.0 - 1.0;\r\n    float k = sqrt(1.0 - z * z);\r\n    return vec3(k * cos(phi), k * sin(phi), z);\r\n}\r\n\r\nfloat sampleHenyeyGreensteinAngleCosine(float g, float U) {\r\n    float g2 = g * g;\r\n    float c = (1.0 - g2) / (1.0 - g + 2.0 * g * U);\r\n    return (1.0 + g2 - c * c) / (2.0 * g);\r\n}\r\n\r\nvec3 sampleHenyeyGreenstein(float g, vec2 U, vec3 direction) {\r\n    // generate random direction and adjust it so that the angle is HG-sampled\r\n    vec3 u = randomDirection(U);\r\n    if (abs(g) < EPS) {\r\n        return u;\r\n    }\r\n    float hgcos = sampleHenyeyGreensteinAngleCosine(g, fract(sin(U.x * 12345.6789) + 0.816723));\r\n    float lambda = hgcos - dot(direction, u);\r\n    return normalize(u + lambda * direction);\r\n}\r\n\r\nvoid main() {\r\n    Photon photon;\r\n    vec2 mappedPosition = vPosition * 0.5 + 0.5;\r\n    photon.position = texture(uPosition, mappedPosition).xyz;\r\n    vec4 directionAndBounces = texture(uDirection, mappedPosition);\r\n    photon.direction = directionAndBounces.xyz;\r\n    photon.bounces = uint(directionAndBounces.w + 0.5);\r\n    photon.transmittance = texture(uTransmittance, mappedPosition).rgb;\r\n    vec4 radianceAndSamples = texture(uRadiance, mappedPosition);\r\n    photon.radiance = radianceAndSamples.rgb;\r\n    photon.samples = uint(radianceAndSamples.w + 0.5);\r\n\r\n    vec2 r = rand(vPosition * uRandSeed);\r\n    for (uint i = 0u; i < uSteps; i++) {\r\n        r = rand(r);\r\n        float t = -log(r.x) / uMajorant;\r\n        photon.position += t * photon.direction;\r\n\r\n        vec4 volumeSample = sampleVolumeColor(photon.position);\r\n        float muAbsorption = volumeSample.a * uAbsorptionCoefficient;\r\n        float muScattering = volumeSample.a * uScatteringCoefficient;\r\n        float muNull = uMajorant - muAbsorption - muScattering;\r\n        float muMajorant = muAbsorption + muScattering + abs(muNull);\r\n        float PNull = abs(muNull) / muMajorant;\r\n        float PAbsorption = muAbsorption / muMajorant;\r\n        float PScattering = muScattering / muMajorant;\r\n\r\n        if (any(greaterThan(photon.position, vec3(1))) || any(lessThan(photon.position, vec3(0)))) {\r\n            // out of bounds\r\n            vec4 envSample = sampleEnvironmentMap(photon.direction);\r\n            vec3 radiance = photon.transmittance * envSample.rgb;\r\n            photon.samples++;\r\n            photon.radiance += (radiance - photon.radiance) / float(photon.samples);\r\n            resetPhoton(r, photon);\r\n        } else if (photon.bounces >= uMaxBounces) {\r\n            // max bounces achieved -> only estimate transmittance\r\n            float weightAS = (muAbsorption + muScattering) / uMajorant;\r\n            photon.transmittance *= 1.0 - weightAS;\r\n        } else if (r.y < PAbsorption) {\r\n            // absorption\r\n            float weightA = muAbsorption / (uMajorant * PAbsorption);\r\n            photon.transmittance *= 1.0 - weightA;\r\n        } else if (r.y < PAbsorption + PScattering) {\r\n            // scattering\r\n            r = rand(r);\r\n            float weightS = muScattering / (uMajorant * PScattering);\r\n            photon.transmittance *= volumeSample.rgb * weightS;\r\n            photon.direction = sampleHenyeyGreenstein(uScatteringBias, r, photon.direction);\r\n            photon.bounces++;\r\n        } else {\r\n            // null collision\r\n            float weightN = muNull / (uMajorant * PNull);\r\n            photon.transmittance *= weightN;\r\n        }\r\n    }\r\n\r\n    oPosition = vec4(photon.position, 0);\r\n    oDirection = vec4(photon.direction, float(photon.bounces));\r\n    oTransmittance = vec4(photon.transmittance, 0);\r\n    oRadiance = vec4(photon.radiance, float(photon.samples));\r\n}\n"},"render":{"vertex":"#version 300 es\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uColor;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = vec4(texture(uColor, vPosition).rgb, 1);\r\n}\n"},"reset":{"vertex":"#version 300 es\r\n\r\nlayout (location = 0) in vec2 aPosition;\r\n\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\n// #link /glsl/mixins/Photon\r\n@Photon\r\n// #link /glsl/mixins/rand\r\n@rand\r\n// #link /glsl/mixins/unprojectRand\r\n@unprojectRand\r\n// #link /glsl/mixins/intersectCube\r\n@intersectCube\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\nuniform vec2 uInverseResolution;\r\nuniform float uRandSeed;\r\nuniform float uBlur;\r\n\r\nin vec2 vPosition;\r\n\r\nlayout (location = 0) out vec4 oPosition;\r\nlayout (location = 1) out vec4 oDirection;\r\nlayout (location = 2) out vec4 oTransmittance;\r\nlayout (location = 3) out vec4 oRadiance;\r\n\r\nvoid main() {\r\n    Photon photon;\r\n    vec3 from, to;\r\n    vec2 randState = rand(vPosition * uRandSeed);\r\n    unprojectRand(randState, vPosition, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\r\n    photon.direction = normalize(to - from);\r\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\r\n    photon.position = from + tbounds.x * photon.direction;\r\n    photon.transmittance = vec3(1);\r\n    photon.radiance = vec3(1);\r\n    photon.bounces = 0u;\r\n    photon.samples = 0u;\r\n    oPosition = vec4(photon.position, 0);\r\n    oDirection = vec4(photon.direction, float(photon.bounces));\r\n    oTransmittance = vec4(photon.transmittance, 0);\r\n    oRadiance = vec4(photon.radiance, float(photon.samples));\r\n}\n"}},"MCS":{"generate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec3 vRayFrom;\r\nout vec3 vRayTo;\r\nout vec2 vPosition;\r\n\r\n// #link /glsl/mixins/unproject\r\n@unproject\r\n\r\nvoid main() {\r\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\n#define M_INVPI 0.31830988618\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform mediump sampler2D uTransferFunction;\r\nuniform mediump sampler2D uEnvironment;\r\nuniform float uOffset;\r\nuniform float uSigmaMax;\r\nuniform float uAlphaCorrection;\r\nuniform vec3 uScatteringDirection;\r\n\r\nin vec3 vRayFrom;\r\nin vec3 vRayTo;\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\n// #link /glsl/mixins/intersectCube\r\n@intersectCube\r\n\r\nvec2 rand(vec2 p) {\r\n    const mat2 M = mat2(\r\n        23.14069263277926, 2.665144142690225,\r\n        12.98987893203892, 78.23376739376591);\r\n    const vec2 D = vec2(\r\n        12345.6789,\r\n        43758.5453);\r\n    vec2 dotted = M * p;\r\n    vec2 mapped = vec2(cos(dotted.x), sin(dotted.y));\r\n    return fract(mapped * D);\r\n}\r\n\r\nvec4 sampleEnvironmentMap(vec3 d) {\r\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\r\n    return texture(uEnvironment, texCoord);\r\n}\r\n\r\nvec4 sampleVolumeColor(vec3 position) {\r\n    vec2 volumeSample = texture(uVolume, position).rg;\r\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\r\n    return transferSample;\r\n}\r\n\r\nfloat sampleDistance(vec3 from, vec3 to, inout vec2 seed) {\r\n    float maxDistance = distance(from, to);\r\n    float dist = 0.0;\r\n    float invSigmaMax = 1.0 / uSigmaMax;\r\n    float invMaxDistance = 1.0 / maxDistance;\r\n\r\n    do {\r\n        seed = rand(seed);\r\n        dist -= log(1.0 - seed.x) * invSigmaMax;\r\n        if (dist > maxDistance) {\r\n            break;\r\n        }\r\n        vec3 samplingPosition = mix(from, to, dist * invMaxDistance);\r\n        vec4 transferSample = sampleVolumeColor(samplingPosition);\r\n        float alphaSample = transferSample.a * uAlphaCorrection;\r\n        if (seed.y < alphaSample * invSigmaMax) {\r\n            break;\r\n        }\r\n    } while (true);\r\n\r\n    return dist;\r\n}\r\n\r\nfloat sampleTransmittance(vec3 from, vec3 to, inout vec2 seed) {\r\n    float maxDistance = distance(from, to);\r\n    float dist = 0.0;\r\n    float invSigmaMax = 1.0 / uSigmaMax;\r\n    float invMaxDistance = 1.0 / maxDistance;\r\n    float transmittance = 1.0;\r\n\r\n    do {\r\n        seed = rand(seed);\r\n        dist -= log(1.0 - seed.x) * invSigmaMax;\r\n        if (dist > maxDistance) {\r\n            break;\r\n        }\r\n        vec3 samplingPosition = mix(from, to, dist * invMaxDistance);\r\n        vec4 transferSample = sampleVolumeColor(samplingPosition);\r\n        float alphaSample = transferSample.a * uAlphaCorrection;\r\n        transmittance *= 1.0 - alphaSample * invSigmaMax;\r\n    } while (true);\r\n\r\n    return transmittance;\r\n}\r\n\r\nvoid main() {\r\n    vec3 rayDirection = vRayTo - vRayFrom;\r\n    vec3 rayDirectionUnit = normalize(rayDirection);\r\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\r\n\r\n    if (tbounds.x >= tbounds.y) {\r\n        oColor = sampleEnvironmentMap(rayDirectionUnit);\r\n    } else {\r\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\r\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\r\n        float maxDistance = distance(from, to);\r\n\r\n        vec2 seed = vPosition + rand(vec2(uOffset, uOffset));\r\n        float dist = sampleDistance(from, to, seed);\r\n\r\n        if (dist > maxDistance) {\r\n            oColor = sampleEnvironmentMap(rayDirectionUnit);\r\n        } else {\r\n            from = mix(from, to, dist / maxDistance);\r\n            tbounds = max(intersectCube(from, uScatteringDirection), 0.0);\r\n            to = from + uScatteringDirection * tbounds.y;\r\n            vec4 diffuseColor = sampleVolumeColor(from);\r\n            vec4 lightColor = sampleEnvironmentMap(uScatteringDirection);\r\n            float transmittance = sampleTransmittance(from, to, seed);\r\n\r\n            oColor = diffuseColor * lightColor * transmittance;\r\n        }\r\n    }\r\n}\n"},"integrate":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\nuniform float uInvFrameNumber;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    vec4 acc = texture(uAccumulator, vPosition);\r\n    vec4 frame = texture(uFrame, vPosition);\r\n    oColor = acc + (frame - acc) * uInvFrameNumber;\r\n}\n"},"render":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = (aPosition + 1.0) * 0.5;\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    vec4 acc = texture(uAccumulator, vPosition);\r\n    oColor = acc;\r\n}\n"},"reset":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    oColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n}\n"}},"MIP":{"generate":{"vertex":"#version 300 es\r\n\r\nuniform mat4 uMvpInverseMatrix;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec3 vRayFrom;\r\nout vec3 vRayTo;\r\n\r\n// #link /glsl/mixins/unproject\r\n@unproject\r\n\r\nvoid main() {\r\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler3D uVolume;\r\nuniform float uStepSize;\r\nuniform float uOffset;\r\n\r\nin vec3 vRayFrom;\r\nin vec3 vRayTo;\r\nout float oColor;\r\n\r\n// #link /glsl/mixins/intersectCube\r\n@intersectCube\r\n\r\nvoid main() {\r\n    vec3 rayDirection = vRayTo - vRayFrom;\r\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\r\n    if (tbounds.x >= tbounds.y) {\r\n        oColor = 0.0;\r\n    } else {\r\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\r\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\r\n\r\n        float t = 0.0;\r\n        float val = 0.0;\r\n        float offset = uOffset;\r\n        vec3 pos;\r\n        do {\r\n            pos = mix(from, to, offset);\r\n            val = max(texture(uVolume, pos).r, val);\r\n            t += uStepSize;\r\n            offset = mod(offset + uStepSize, 1.0);\r\n        } while (t < 1.0);\r\n        oColor = val;\r\n    }\r\n}\n"},"integrate":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\nuniform mediump sampler2D uFrame;\r\n\r\nin vec2 vPosition;\r\nout float oColor;\r\n\r\nvoid main() {\r\n    float acc = texture(uAccumulator, vPosition).r;\r\n    float frame = texture(uFrame, vPosition).r;\r\n    oColor = max(acc, frame);\r\n}\n"},"render":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uAccumulator;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    float acc = texture(uAccumulator, vPosition).r;\r\n    oColor = vec4(acc, acc, acc, 1);\r\n}\n"},"reset":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout float oColor;\r\n\r\nvoid main() {\r\n    oColor = 0.0;\r\n}\n"}}},"test":{"vertex":"#version 300 es\r\nprecision mediump float;\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nout vec4 color;\r\n\r\nvoid main() {\r\n    color = vec4(1.0, 0.5, 0.2, 1.0);\r\n}\n"},"AcesToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvec3 aces(vec3 x) {\r\n    const float a = 2.51;\r\n    const float b = 0.03;\r\n    const float c = 2.43;\r\n    const float d = 0.59;\r\n    const float e = 0.14;\r\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\r\n}\r\n\r\nfloat aces(float x) {\r\n    const float a = 2.51;\r\n    const float b = 0.03;\r\n    const float c = 2.43;\r\n    const float d = 0.59;\r\n    const float e = 0.14;\r\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = vec4(aces(src.rgb * uExposure), 1);\r\n}\n"},"ArtisticToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\n#define M_PI 3.1415926535897932384626\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uLow;\r\nuniform float uMid;\r\nuniform float uHigh;\r\nuniform float uSaturation;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    vec4 color = texture(uTexture, vPosition);\r\n    color = (color - uLow) / (uHigh - uLow);\r\n    const vec3 gray = normalize(vec3(1));\r\n    color = vec4(mix(dot(color.rgb, gray) * gray, color.rgb, uSaturation), 1.0);\r\n    float midpoint = (uMid - uLow) / (uHigh - uLow);\r\n    float exponent = -log(2.0) / log(midpoint);\r\n    color = pow(color, vec4(exponent));\r\n    oColor = vec4(color.rgb, 1.0);\r\n}\n"},"FilmicToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvec3 filmic(vec3 x) {\r\n    vec3 X = max(vec3(0.0), x - 0.004);\r\n    vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r\n    return pow(result, vec3(2.2));\r\n}\r\n\r\nfloat filmic(float x) {\r\n    float X = max(0.0, x - 0.004);\r\n    float result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r\n    return pow(result, 2.2);\r\n}\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = vec4(filmic(src.rgb * uExposure), 1);\r\n}\n"},"LottesToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvec3 lottes(vec3 x) {\r\n    const vec3 a = vec3(1.6);\r\n    const vec3 d = vec3(0.977);\r\n    const vec3 hdrMax = vec3(8.0);\r\n    const vec3 midIn = vec3(0.18);\r\n    const vec3 midOut = vec3(0.267);\r\n\r\n    const vec3 b =\r\n        (-pow(midIn, a) + pow(hdrMax, a) * midOut) /\r\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\r\n    const vec3 c =\r\n        (pow(hdrMax, a * d) * pow(midIn, a) - pow(hdrMax, a) * pow(midIn, a * d) * midOut) /\r\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\r\n\r\n    return pow(x, a) / (pow(x, a * d) * b + c);\r\n}\r\n\r\nfloat lottes(float x) {\r\n    const float a = 1.6;\r\n    const float d = 0.977;\r\n    const float hdrMax = 8.0;\r\n    const float midIn = 0.18;\r\n    const float midOut = 0.267;\r\n\r\n    const float b =\r\n        (-pow(midIn, a) + pow(hdrMax, a) * midOut) /\r\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\r\n    const float c =\r\n        (pow(hdrMax, a * d) * pow(midIn, a) - pow(hdrMax, a) * pow(midIn, a * d) * midOut) /\r\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\r\n\r\n    return pow(x, a) / (pow(x, a * d) * b + c);\r\n}\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = vec4(lottes(src.rgb * uExposure), 1);\r\n}\n"},"RangeToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uMin;\r\nuniform float uMax;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = (src - uMin) / (uMax - uMin);\r\n}\n"},"Reinhard2ToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvec3 reinhard2(vec3 x) {\r\n    const float L_white = 4.0;\r\n    return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\r\n}\r\n\r\nfloat reinhard2(float x) {\r\n    const float L_white = 4.0;\r\n    return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\r\n}\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = vec4(reinhard2(src.rgb * uExposure), 1);\r\n}\n"},"ReinhardToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvec3 reinhard(vec3 x) {\r\n    return x / (1.0 + x);\r\n}\r\n\r\nfloat reinhard(float x) {\r\n    return x / (1.0 + x);\r\n}\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = vec4(reinhard(src.rgb * uExposure), 1);\r\n}\n"},"UchimuraToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvec3 uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\r\n    float l0 = ((P - m) * l) / a;\r\n    float L0 = m - m / a;\r\n    float L1 = m + (1.0 - m) / a;\r\n    float S0 = m + l0;\r\n    float S1 = m + a * l0;\r\n    float C2 = (a * P) / (P - S1);\r\n    float CP = -C2 / P;\r\n\r\n    vec3 w0 = vec3(1.0 - smoothstep(0.0, m, x));\r\n    vec3 w2 = vec3(step(m + l0, x));\r\n    vec3 w1 = vec3(1.0 - w0 - w2);\r\n\r\n    vec3 T = vec3(m * pow(x / m, vec3(c)) + b);\r\n    vec3 S = vec3(P - (P - S1) * exp(CP * (x - S0)));\r\n    vec3 L = vec3(m + a * (x - m));\r\n\r\n    return T * w0 + L * w1 + S * w2;\r\n}\r\n\r\nvec3 uchimura(vec3 x) {\r\n    const float P = 1.0;  // max display brightness\r\n    const float a = 1.0;  // contrast\r\n    const float m = 0.22; // linear section start\r\n    const float l = 0.4;  // linear section length\r\n    const float c = 1.33; // black\r\n    const float b = 0.0;  // pedestal\r\n\r\n    return uchimura(x, P, a, m, l, c, b);\r\n}\r\n\r\nfloat uchimura(float x, float P, float a, float m, float l, float c, float b) {\r\n    float l0 = ((P - m) * l) / a;\r\n    float L0 = m - m / a;\r\n    float L1 = m + (1.0 - m) / a;\r\n    float S0 = m + l0;\r\n    float S1 = m + a * l0;\r\n    float C2 = (a * P) / (P - S1);\r\n    float CP = -C2 / P;\r\n\r\n    float w0 = 1.0 - smoothstep(0.0, m, x);\r\n    float w2 = step(m + l0, x);\r\n    float w1 = 1.0 - w0 - w2;\r\n\r\n    float T = m * pow(x / m, c) + b;\r\n    float S = P - (P - S1) * exp(CP * (x - S0));\r\n    float L = m + a * (x - m);\r\n\r\n    return T * w0 + L * w1 + S * w2;\r\n}\r\n\r\nfloat uchimura(float x) {\r\n    const float P = 1.0;  // max display brightness\r\n    const float a = 1.0;  // contrast\r\n    const float m = 0.22; // linear section start\r\n    const float l = 0.4;  // linear section length\r\n    const float c = 1.33; // black\r\n    const float b = 0.0;  // pedestal\r\n\r\n    return uchimura(x, P, a, m, l, c, b);\r\n}\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = vec4(uchimura(src.rgb * uExposure), 1);\r\n}\n"},"Uncharted2ToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvec3 uncharted2Tonemap(vec3 x) {\r\n    float A = 0.15;\r\n    float B = 0.50;\r\n    float C = 0.10;\r\n    float D = 0.20;\r\n    float E = 0.02;\r\n    float F = 0.30;\r\n    float W = 11.2;\r\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\r\n}\r\n\r\nvec3 uncharted2(vec3 color) {\r\n    const float W = 11.2;\r\n    float exposureBias = 2.0;\r\n    vec3 curr = uncharted2Tonemap(exposureBias * color);\r\n    vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W));\r\n    return curr * whiteScale;\r\n}\r\n\r\nfloat uncharted2Tonemap(float x) {\r\n    float A = 0.15;\r\n    float B = 0.50;\r\n    float C = 0.10;\r\n    float D = 0.20;\r\n    float E = 0.02;\r\n    float F = 0.30;\r\n    float W = 11.2;\r\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\r\n}\r\n\r\nfloat uncharted2(float color) {\r\n    const float W = 11.2;\r\n    const float exposureBias = 2.0;\r\n    float curr = uncharted2Tonemap(exposureBias * color);\r\n    float whiteScale = 1.0 / uncharted2Tonemap(W);\r\n    return curr * whiteScale;\r\n}\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = vec4(uncharted2(src.rgb * uExposure), 1);\r\n}\n"},"UnrealToneMapper":{"vertex":"#version 300 es\r\n\r\nlayout(location = 0) in vec2 aPosition;\r\nout vec2 vPosition;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(aPosition, 0, 1);\r\n    vPosition = aPosition * 0.5 + 0.5;\r\n}\n","fragment":"#version 300 es\r\nprecision mediump float;\r\n\r\nuniform mediump sampler2D uTexture;\r\nuniform float uExposure;\r\n\r\nin vec2 vPosition;\r\nout vec4 oColor;\r\n\r\nvec3 unreal(vec3 x) {\r\n    return x / (x + 0.155) * 1.019;\r\n}\r\n\r\nfloat unreal(float x) {\r\n    return x / (x + 0.155) * 1.019;\r\n}\r\n\r\nvoid main() {\r\n    vec4 src = texture(uTexture, vPosition);\r\n    oColor = vec4(unreal(src.rgb * uExposure), 1);\r\n}\n"}}